<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超級彈珠台 - 東東遊戲中心</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap">
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --accent-color: #4fc3f7;
            --background-color: #121212;
            --text-color: #e0e0e0;
            --header-bg: #1a1a1a;
            --header-text: #ffffff;
            --ball-color: #FF5252;
            --paddle-color: #4CAF50;
            --brick-colors: ['#FF5252', '#FFD740', '#64FFDA', '#448AFF', '#B388FF'];
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 0;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 700;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            flex-grow: 1;
            position: relative;
        }

        canvas {
            background-color: #000;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 480px;
            margin-bottom: 1rem;
            background-color: #1e1e1e;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .info-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .info-title {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 0.3rem;
        }

        .info-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .controls {
            margin-top: 2rem;
            text-align: center;
        }

        .controls-info {
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #666;
        }

        .mobile-controls {
            display: none;
        }

        .direction-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .direction-btn {
            width: 80px;
            height: 60px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background-color: var(--primary-color);
        }

        footer {
            background-color: var(--header-bg);
            color: var(--header-text);
            text-align: center;
            padding: 1rem;
            margin-top: auto;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #2d2d2d;
            padding: 2rem;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .modal p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }

        .difficulty-selector {
            margin: 1.5rem 0;
        }

        .difficulty-selector label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .difficulty-selector select {
            width: 100%;
            padding: 0.8rem;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #3d3d3d;
            color: white;
            font-size: 1rem;
        }

        .powerups {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
            justify-content: center;
        }

        .powerup {
            background-color: #3d3d3d;
            padding: 1rem;
            border-radius: 8px;
            width: 120px;
            text-align: center;
        }

        .powerup-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .powerup-name {
            font-weight: bold;
            margin-bottom: 0.3rem;
        }

        .powerup-desc {
            font-size: 0.8rem;
            color: #aaa;
        }

        .key-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .key-control {
            background-color: #3d3d3d;
            padding: 0.8rem;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .key {
            background-color: #1a1a1a;
            color: var(--accent-color);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            .game-info {
                width: 90%;
            }

            canvas {
                width: 100%;
                max-width: 400px;
                height: auto;
            }

            .mobile-controls {
                display: block;
            }

            .desktop-controls {
                display: none;
            }
        }

        @media (max-width: 480px) {
            header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }

            .header-controls {
                width: 100%;
                justify-content: space-between;
            }

            .game-info {
                flex-direction: column;
                gap: 0.5rem;
                align-items: center;
            }
        }

        /* 粒子效果 */
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        /* 連擊效果 */
        .combo {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 5px #FF0000;
            animation: comboPop 0.5s ease-out;
            pointer-events: none;
            z-index: 20;
        }

        @keyframes comboPop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <header>
        <h1>超級彈珠台 - 東東遊戲中心</h1>
        <div class="header-controls">
            <button id="newGameBtn">新遊戲</button>
            <button id="helpBtn">遊戲說明</button>
            <button id="homeButton">回到主頁</button>
        </div>
    </header>

    <div class="game-container">
        <div class="game-info">
            <div class="info-box">
                <div class="info-title">分數</div>
                <div class="info-value" id="score">0</div>
            </div>
            <div class="info-box">
                <div class="info-title">生命</div>
                <div class="info-value" id="lives">3</div>
            </div>
            <div class="info-box">
                <div class="info-title">等級</div>
                <div class="info-value" id="level">1</div>
            </div>
            <div class="info-box">
                <div class="info-title">連擊</div>
                <div class="info-value" id="combo">0</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="480" height="320"></canvas>
        
        <div class="controls">
            <p class="controls-info desktop-controls">控制: 方向鍵或數字鍵 (1=左移, 3=右移, 空格=發球)</p>
            
            <div class="mobile-controls">
                <div class="direction-buttons">
                    <button class="direction-btn" id="leftBtn">← 左移</button>
                    <button class="direction-btn" id="rightBtn">→ 右移</button>
                    <button class="direction-btn" id="launchBtn" style="background-color: #f44336;">發球</button>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>© 2025 東東遊戲中心 - 超級彈珠台</p>
    </footer>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <h2>遊戲說明</h2>
            <p>使用擋板反彈球體，擊碎所有磚塊即可過關。每關難度會逐漸提升，獲得特殊能力來幫助你通關！</p>
            
            <div class="key-controls">
                <div class="key-control">
                    <div class="key">← 或 1</div>
                    <div>左移擋板</div>
                </div>
                <div class="key-control">
                    <div class="key">→ 或 3</div>
                    <div>右移擋板</div>
                </div>
                <div class="key-control">
                    <div class="key">空格</div>
                    <div>發球/使用能力</div>
                </div>
                <div class="key-control">
                    <div class="key">P</div>
                    <div>暫停遊戲</div>
                </div>
            </div>
            
            <h3>得分規則</h3>
            <p>- 普通磚塊: 10分 × 等級</p>
            <p>- 特殊磚塊: 50-200分</p>
            <p>- 連擊獎勵: 每連續擊中磚塊獲得額外分數</p>
            <p>- 關卡獎勵: 每關完成獲得1000分</p>
            
            <h3>能力系統</h3>
            <div class="powerups">
                <div class="powerup">
                    <div class="powerup-icon">🔶</div>
                    <div class="powerup-name">雙倍球</div>
                    <div class="powerup-desc">同時有兩個球在場上</div>
                </div>
                <div class="powerup">
                    <div class="powerup-icon">🔷</div>
                    <div class="powerup-name">大擋板</div>
                    <div class="powerup-desc">擋板變大30秒</div>
                </div>
                <div class="powerup">
                    <div class="powerup-icon">💥</div>
                    <div class="powerup-name">爆炸球</div>
                    <div class="powerup-desc">球可以炸碎周圍磚塊</div>
                </div>
                <div class="powerup">
                    <div class="powerup-icon">🧲</div>
                    <div class="powerup-name">磁力</div>
                    <div class="powerup-desc">可以吸附球再發射</div>
                </div>
            </div>
            
            <button id="closeHelpBtn">關閉</button>
        </div>
    </div>

    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameResultTitle">遊戲結束!</h2>
            <p>你的分數: <span id="finalScore">0</span></p>
            <p>最高分: <span id="finalHighScore">0</span></p>
            <p>達到等級: <span id="finalLevel">1</span></p>
            <p>擊碎磚塊: <span id="finalBricks">0</span></p>
            
            <div class="difficulty-selector">
                <label for="difficulty">選擇難度:</label>
                <select id="difficulty">
                    <option value="slow">簡單 (慢速)</option>
                    <option value="normal" selected>普通 (中速)</option>
                    <option value="fast">困難 (快速)</option>
                    <option value="expert">專家 (極速)</option>
                </select>
            </div>
            
            <button id="restartBtn">再玩一次</button>
        </div>
    </div>

    <div class="modal" id="levelUpModal">
        <div class="modal-content">
            <h2>恭喜過關!</h2>
            <p>你已成功完成第 <span id="currentLevel">1</span> 關</p>
            <p>獲得獎勵: <span id="levelBonus">1000</span> 分</p>
            <p>下一關難度將提升!</p>
            <div id="powerupReward" style="margin: 1rem 0; font-size: 2rem;"></div>
            <button id="nextLevelBtn">進入下一關</button>
        </div>
    </div>

    <script>
        // 遊戲常量
        const BRICK_COLORS = [
            '#FF5252', '#FFD740', '#64FFDA', 
            '#448AFF', '#B388FF', '#FF80AB',
            '#69F0AE', '#FFFF00', '#00BFA5'
        ];
        const BRICK_TYPES = {
            NORMAL: 1,
            HARD: 2,
            UNBREAKABLE: 3,
            SPEED_UP: 4,
            POWER_UP: 5,
            BONUS: 6
        };
        
        const POWERUP_TYPES = {
            EXTRA_BALL: 'extra_ball',
            LARGE_PADDLE: 'large_paddle',
            FIRE_BALL: 'fire_ball',
            STICKY_PADDLE: 'sticky_paddle'
        };
        
        // 遊戲變數
        let canvas, ctx;
        let ball = {
            x: 0,
            y: 0,
            dx: 0,
            dy: 0,
            radius: 8,
            speed: 4,
            active: false
        };
        let balls = [];
        let paddle = {
            width: 75,
            height: 10,
            x: 0,
            speed: 8,
            isSticky: false,
            isLarge: false,
            largeEndTime: 0
        };
        let bricks = [];
        let score = 0;
        let highScore = localStorage.getItem('breakoutHighScore') || 0;
        let lives = 3;
        let level = 1;
        let combo = 0;
        let maxCombo = 0;
        let comboTimeout;
        let gameOver = false;
        let isPaused = false;
        let brickRowCount = 5;
        let brickColumnCount = 8;
        let brickWidth = 50;
        let brickHeight = 20;
        let brickPadding = 10;
        let brickOffsetTop = 30;
        let brickOffsetLeft = 30;
        let rightPressed = false;
        let leftPressed = false;
        let spacePressed = false;
        let lastTime = 0;
        let animationId;
        let difficulty = 'normal';
        let powerups = [];
        let activePowerups = [];
        let particles = [];
        let totalBricksDestroyed = 0;
        
        // 初始化遊戲
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 設置事件監聽器
            setupEventListeners();
            
            // 開始新遊戲
            startNewGame();
        }
        
        // 開始新遊戲
        function startNewGame() {
            // 重置遊戲狀態
            resetGame();
            
            // 關閉所有模態框
            document.getElementById('helpModal').style.display = 'none';
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('levelUpModal').style.display = 'none';
            
            // 獲取選擇的難度
            difficulty = document.getElementById('difficulty').value;
            
            // 開始遊戲循環
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            lastTime = performance.now();
            gameLoop(lastTime);
        }
        
        // 重置遊戲狀態
        function resetGame() {
            // 初始化球
            ball = {
                x: canvas.width / 2,
                y: canvas.height - 30,
                dx: 0,
                dy: 0,
                radius: 8,
                speed: getBallSpeed(),
                active: false,
                isFireball: false,
                fireballEndTime: 0
            };
            balls = [ball];
            
            // 初始化擋板
            paddle = {
                width: 75,
                height: 10,
                x: (canvas.width - 75) / 2,
                speed: 8,
                isSticky: false,
                isLarge: false,
                largeEndTime: 0
            };
            
            // 初始化磚塊
            createBricks();
            
            // 重置其他變數
            score = 0;
            lives = 3;
            level = 1;
            combo = 0;
            maxCombo = 0;
            gameOver = false;
            isPaused = false;
            powerups = [];
            activePowerups = [];
            particles = [];
            totalBricksDestroyed = 0;
            
            // 更新顯示
            updateScoreDisplay();
        }
        
        // 下一關
        function nextLevel() {
            level++;
            document.getElementById('level').textContent = level;
            
            // 給予關卡獎勵
            const levelBonus = level * 1000;
            addScore(levelBonus);
            document.getElementById('levelBonus').textContent = levelBonus;
            
            // 隨機給予能力獎勵
            const powerupTypes = Object.values(POWERUP_TYPES);
            const randomPowerup = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
            const powerupRewardEl = document.getElementById('powerupReward');
            
            switch(randomPowerup) {
                case POWERUP_TYPES.EXTRA_BALL:
                    powerupRewardEl.textContent = '🎁 獲得能力: 雙倍球 🔶';
                    break;
                case POWERUP_TYPES.LARGE_PADDLE:
                    powerupRewardEl.textContent = '🎁 獲得能力: 大擋板 🔷';
                    break;
                case POWERUP_TYPES.FIRE_BALL:
                    powerupRewardEl.textContent = '🎁 獲得能力: 爆炸球 💥';
                    break;
                case POWERUP_TYPES.STICKY_PADDLE:
                    powerupRewardEl.textContent = '🎁 獲得能力: 磁力擋板 🧲';
                    break;
            }
            
            // 激活能力
            activatePowerup(randomPowerup);
            
            // 重置遊戲狀態
            ball = {
                x: canvas.width / 2,
                y: canvas.height - 30,
                dx: 0,
                dy: 0,
                radius: 8,
                speed: getBallSpeed(),
                active: false,
                isFireball: false,
                fireballEndTime: 0
            };
            balls = [ball];
            
            // 初始化磚塊
            createBricks();
            
            // 關閉升級模態框
            document.getElementById('levelUpModal').style.display = 'none';
        }
        
        // 創建磚塊布局
        function createBricks() {
            bricks = [];
            brickRowCount = 5 + Math.floor(level / 2);
            brickColumnCount = 8 + Math.floor(level / 3);
            
            // 調整磚塊大小以適應畫布
            const availableWidth = canvas.width - brickOffsetLeft * 2;
            brickWidth = Math.max(30, Math.floor((availableWidth - (brickColumnCount - 1) * brickPadding) / brickColumnCount));
            
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    // 隨機決定磚塊類型 (高級關卡有更多特殊磚塊)
                    let type = BRICK_TYPES.NORMAL;
                    const rand = Math.random();
                    
                    if (level > 3 && rand < 0.05) {
                        type = BRICK_TYPES.UNBREAKABLE;
                    } else if (level > 2 && rand < 0.1) {
                        type = BRICK_TYPES.HARD;
                    } else if (level > 1 && rand < 0.1) {
                        type = BRICK_TYPES.POWER_UP;
                    } else if (rand < 0.1) {
                        type = BRICK_TYPES.BONUS;
                    } else if (rand < 0.15) {
                        type = BRICK_TYPES.SPEED_UP;
                    }
                    
                    bricks[c][r] = {
                        x: 0,
                        y: 0,
                        status: 1,
                        type: type,
                        hits: type === BRICK_TYPES.HARD ? 2 : 1
                    };
                }
            }
        }
        
        // 設置事件監聽器
        function setupEventListeners() {
            // 鍵盤控制
            document.addEventListener('keydown', keyDownHandler);
            document.addEventListener('keyup', keyUpHandler);
            document.addEventListener('mousemove', mouseMoveHandler);
            
            // 按鈕事件
            document.getElementById('newGameBtn').addEventListener('click', startNewGame);
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('helpModal').style.display = 'flex';
            });
            document.getElementById('closeHelpBtn').addEventListener('click', () => {
                document.getElementById('helpModal').style.display = 'none';
            });
            document.getElementById('restartBtn').addEventListener('click', startNewGame);
            document.getElementById('homeButton').addEventListener('click', () => {
                window.location.href = "index.html";
            });
            document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
            
            // 移動控制按鈕
            document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                leftPressed = true;
            });
            document.getElementById('leftBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                leftPressed = false;
            });
            document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                rightPressed = true;
            });
            document.getElementById('rightBtn').addEventListener('touchend', (e) => {
                e.preventDefault();
                rightPressed = false;
            });
            document.getElementById('launchBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                launchBall();
            });
            
            // 點擊模態框外部關閉
            window.addEventListener('click', (e) => {
                if (e.target === document.getElementById('helpModal')) {
                    document.getElementById('helpModal').style.display = 'none';
                }
                if (e.target === document.getElementById('gameOverModal')) {
                    document.getElementById('gameOverModal').style.display = 'none';
                }
            });
        }
        
        // 鍵盤按下處理
        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight' || e.key === '3') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft' || e.key === '1') {
                leftPressed = true;
            } else if (e.key === ' ' || e.key === 'Spacebar') {
                spacePressed = true;
                launchBall();
            } else if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        }
        
        // 鍵盤釋放處理
        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight' || e.key === '3') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft' || e.key === '1') {
                leftPressed = false;
            } else if (e.key === ' ' || e.key === 'Spacebar') {
                spacePressed = false;
            }
        }
        
        // 滑鼠移動處理
        function mouseMoveHandler(e) {
            const relativeX = e.clientX - canvas.offsetLeft;
            if (relativeX > 0 && relativeX < canvas.width) {
                paddle.x = relativeX - paddle.width / 2;
                
                // 限制擋板不超出畫布
                if (paddle.x < 0) {
                    paddle.x = 0;
                } else if (paddle.x + paddle.width > canvas.width) {
                    paddle.x = canvas.width - paddle.width;
                }
            }
        }
        
        // 發射球
        function launchBall() {
            // 如果有球已經在活動，不做任何事
            if (balls.some(b => b.active)) return;
            
            // 如果有粘性擋板，釋放所有球
            if (paddle.isSticky) {
                balls.forEach(b => {
                    if (!b.active) {
                        b.active = true;
                        b.dx = Math.random() * 2 - 1; // -1 到 1 之間的隨機數
                        b.dy = -2; // 向上
                        
                        // 標準化方向向量
                        const length = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                        b.dx /= length;
                        b.dy /= length;
                    }
                });
            } else {
                // 否則只發射主球
                ball.active = true;
                ball.dx = Math.random() * 2 - 1; // -1 到 1 之間的隨機數
                ball.dy = -2; // 向上
                
                // 標準化方向向量
                const length = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx /= length;
                ball.dy /= length;
            }
        }
        
        // 切換暫停狀態
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                document.getElementById('helpModal').style.display = 'flex';
            } else {
                document.getElementById('helpModal').style.display = 'none';
            }
        }
        
        // 根據難度獲取球速
        function getBallSpeed() {
            switch(difficulty) {
                case 'slow': return 3;
                case 'normal': return 4;
                case 'fast': return 5;
                case 'expert': return 6;
                default: return 4;
            }
        }
        
        // 遊戲主循環
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            if (!gameOver && !isPaused) {
                // 清除畫布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 繪製遊戲元素
                drawBricks();
                drawPaddle();
                drawBalls();
                drawPowerups();
                drawParticles();
                
                // 更新遊戲狀態
                updateBalls(deltaTime);
                updatePaddle();
                updatePowerups(deltaTime);
                updateParticles(deltaTime);
                
                // 碰撞檢測
                collisionDetection();
                
                // 檢查遊戲狀態
                checkGameState();
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // 繪製磚塊
        function drawBricks() {
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    const brick = bricks[c][r];
                    if (brick.status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        brick.x = brickX;
                        brick.y = brickY;
                        
                        // 根據磚塊類型設置顏色
                        let color;
                        switch(brick.type) {
                            case BRICK_TYPES.HARD:
                                color = '#9E9E9E'; // 灰色
                                break;
                            case BRICK_TYPES.UNBREAKABLE:
                                color = '#212121'; // 深灰色
                                break;
                            case BRICK_TYPES.SPEED_UP:
                                color = '#FFC107'; // 琥珀色
                                break;
                            case BRICK_TYPES.POWER_UP:
                                color = '#9C27B0'; // 紫色
                                break;
                            case BRICK_TYPES.BONUS:
                                color = '#FFEB3B'; // 黃色
                                break;
                            default:
                                // 普通磚塊使用彩虹色
                                color = BRICK_COLORS[r % BRICK_COLORS.length];
                        }
                        
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = color;
                        ctx.fill();
                        
                        // 添加磚塊細節
                        if (brick.type === BRICK_TYPES.HARD) {
                            ctx.strokeStyle = '#616161';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(brickX + 2, brickY + 2, brickWidth - 4, brickHeight - 4);
                        } else if (brick.type === BRICK_TYPES.UNBREAKABLE) {
                            ctx.strokeStyle = '#424242';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(brickX + 2, brickY + 2, brickWidth - 4, brickHeight - 4);
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.fillRect(brickX + 4, brickY + 4, brickWidth - 8, brickHeight - 8);
                        } else if (brick.type === BRICK_TYPES.POWER_UP) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            ctx.beginPath();
                            ctx.arc(
                                brickX + brickWidth / 2, 
                                brickY + brickHeight / 2, 
                                Math.min(brickWidth, brickHeight) / 3, 
                                0, 
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                        
                        ctx.closePath();
                    }
                }
            }
        }
        
        // 繪製擋板
        function drawPaddle() {
            const width = paddle.isLarge ? paddle.width * 1.5 : paddle.width;
            const x = paddle.isLarge ? paddle.x - (width - paddle.width) / 2 : paddle.x;
            
            ctx.beginPath();
            ctx.rect(x, canvas.height - paddle.height, width, paddle.height);
            
            // 漸變色
            const gradient = ctx.createLinearGradient(x, 0, x + width, 0);
            gradient.addColorStop(0, '#4CAF50');
            gradient.addColorStop(1, '#8BC34A');
            ctx.fillStyle = gradient;
            
            ctx.fill();
            ctx.closePath();
            
            // 如果是粘性擋板，添加效果
            if (paddle.isSticky) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(
                    x + width / 2, 
                    canvas.height - paddle.height, 
                    width / 4, 
                    0, 
                    Math.PI
                );
                ctx.fill();
                ctx.closePath();
            }
        }
        
        // 繪製球
        function drawBalls() {
            balls.forEach(b => {
                if (!b.active) return;
                
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                
                // 如果是火球，使用火焰效果
                if (b.isFireball) {
                    const gradient = ctx.createRadialGradient(
                        b.x, b.y, b.radius / 2,
                        b.x, b.y, b.radius
                    );
                    gradient.addColorStop(0, '#FF5722');
                    gradient.addColorStop(1, '#FFC107');
                    ctx.fillStyle = gradient;
                    
                    // 火焰效果
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(
                            b.x + (Math.random() - 0.5) * b.radius, 
                            b.y + (Math.random() - 0.5) * b.radius, 
                            b.radius * (0.3 + Math.random() * 0.7), 
                            0, 
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                } else {
                    // 普通球使用漸變色
                    const gradient = ctx.createRadialGradient(
                        b.x, b.y, 0,
                        b.x, b.y, b.radius
                    );
                    gradient.addColorStop(0, '#2196F3');
                    gradient.addColorStop(1, '#0D47A1');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
                ctx.closePath();
            });
        }
       // 繪製能力道具
function drawPowerups() {
    powerups.forEach(pu => {
        ctx.beginPath();
        ctx.rect(pu.x, pu.y, pu.width, pu.height);
        
        // 根據能力類型設置不同顏色和圖標
        switch(pu.type) {
            case POWERUP_TYPES.EXTRA_BALL:
                ctx.fillStyle = '#FF5252'; // 紅色
                break;
            case POWERUP_TYPES.LARGE_PADDLE:
                ctx.fillStyle = '#4CAF50'; // 綠色
                break;
            case POWERUP_TYPES.FIRE_BALL:
                ctx.fillStyle = '#FF9800'; // 橙色
                break;
            case POWERUP_TYPES.STICKY_PADDLE:
                ctx.fillStyle = '#2196F3'; // 藍色
                break;
            default:
                ctx.fillStyle = '#9C27B0'; // 紫色
        }
        
        ctx.fill();
        ctx.closePath();
        
        // 添加能力圖標
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        let icon = '';
        switch(pu.type) {
            case POWERUP_TYPES.EXTRA_BALL:
                icon = '🔶';
                break;
            case POWERUP_TYPES.LARGE_PADDLE:
                icon = '🔷';
                break;
            case POWERUP_TYPES.FIRE_BALL:
                icon = '💥';
                break;
            case POWERUP_TYPES.STICKY_PADDLE:
                icon = '🧲';
                break;
        }
        
        ctx.fillText(icon, pu.x + pu.width/2, pu.y + pu.height/2);
    });
}

// 繪製粒子效果
function drawParticles() {
    particles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.closePath();
    });
}

// 更新球的位置
function updateBalls(deltaTime) {
    const timeFactor = deltaTime / 16; // 標準化時間因子
    
    balls.forEach(b => {
        if (!b.active) {
            // 如果球未激活，跟隨擋板移動
            b.x = paddle.x + paddle.width / 2;
            b.y = canvas.height - paddle.height - b.radius;
            return;
        }
        
        // 更新球的位置
        b.x += b.dx * b.speed * timeFactor;
        b.y += b.dy * b.speed * timeFactor;
        
        // 邊界碰撞檢測
        if (b.x + b.dx > canvas.width - b.radius || b.x + b.dx < b.radius) {
            b.dx = -b.dx;
        }
        
        // 頂部碰撞
        if (b.y + b.dy < b.radius) {
            b.dy = -b.dy;
        }
        
        // 底部碰撞 - 失去生命
        if (b.y + b.dy > canvas.height - b.radius) {
            // 如果有其他球在活動，只移除這個球
            if (balls.length > 1) {
                balls = balls.filter(ball => ball !== b);
            } else {
                // 這是最後一個球
                lives--;
                document.getElementById('lives').textContent = lives;
                
                if (lives <= 0) {
                    gameOver = true;
                    showGameOver();
                } else {
                    // 重置球
                    b.x = canvas.width / 2;
                    b.y = canvas.height - 30;
                    b.dx = 0;
                    b.dy = 0;
                    b.active = false;
                    b.speed = getBallSpeed();
                    
                    // 重置擋板位置
                    paddle.x = (canvas.width - paddle.width) / 2;
                }
            }
        }
        
        // 擋板碰撞檢測
        const paddleWidth = paddle.isLarge ? paddle.width * 1.5 : paddle.width;
        const paddleX = paddle.isLarge ? paddle.x - (paddleWidth - paddle.width) / 2 : paddle.x;
        
        if (
            b.y + b.dy > canvas.height - paddle.height - b.radius &&
            b.x > paddleX && 
            b.x < paddleX + paddleWidth
        ) {
            // 計算碰撞點（-0.5到0.5之間的值）
            const hitPos = (b.x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
            
            // 根據碰撞點改變球的角度
            const angle = hitPos * Math.PI / 3; // 最大60度角
            b.dx = Math.sin(angle);
            b.dy = -Math.cos(angle);
            
            // 標準化方向向量
            const length = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
            b.dx /= length;
            b.dy /= length;
            
            // 如果是粘性擋板，吸附球
            if (paddle.isSticky && !b.active) {
                b.active = false;
            }
            
            // 播放聲音效果
            playSound('paddle');
        }
    });
}

// 更新擋板位置
function updatePaddle() {
    if (rightPressed && paddle.x < canvas.width - paddle.width) {
        paddle.x += paddle.speed;
    } else if (leftPressed && paddle.x > 0) {
        paddle.x -= paddle.speed;
    }
    
    // 檢查大擋板時間是否結束
    if (paddle.isLarge && Date.now() > paddle.largeEndTime) {
        paddle.isLarge = false;
    }
}

// 更新能力道具
function updatePowerups(deltaTime) {
    const timeFactor = deltaTime / 16; // 標準化時間因子
    
    // 更新能力道具位置
    powerups.forEach(pu => {
        pu.y += pu.speed * timeFactor;
    });
    
    // 移除超出屏幕的能力道具
    powerups = powerups.filter(pu => pu.y < canvas.height);
    
    // 檢查能力道具與擋板的碰撞
    powerups.forEach((pu, index) => {
        const paddleWidth = paddle.isLarge ? paddle.width * 1.5 : paddle.width;
        const paddleX = paddle.isLarge ? paddle.x - (paddleWidth - paddle.width) / 2 : paddle.x;
        
        if (
            pu.y + pu.height > canvas.height - paddle.height &&
            pu.x + pu.width > paddleX && 
            pu.x < paddleX + paddleWidth
        ) {
            // 激活能力
            activatePowerup(pu.type);
            
            // 移除能力道具
            powerups.splice(index, 1);
            
            // 播放聲音效果
            playSound('powerup');
        }
    });
    
    // 檢查激活的能力是否過期
    activePowerups.forEach((pu, index) => {
        if (Date.now() > pu.endTime) {
            // 能力失效
            deactivatePowerup(pu.type);
            activePowerups.splice(index, 1);
        }
    });
    
    // 檢查火球是否過期
    balls.forEach(b => {
        if (b.isFireball && Date.now() > b.fireballEndTime) {
            b.isFireball = false;
        }
    });
}

// 更新粒子效果
function updateParticles(deltaTime) {
    const timeFactor = deltaTime / 16; // 標準化時間因子
    
    particles.forEach(p => {
        p.x += p.dx * timeFactor;
        p.y += p.dy * timeFactor;
        p.alpha -= 0.01 * timeFactor;
        p.radius -= 0.1 * timeFactor;
    });
    
    // 移除不可見的粒子
    particles = particles.filter(p => p.alpha > 0 && p.radius > 0);
}

// 碰撞檢測
function collisionDetection() {
    for (let c = 0; c < bricks.length; c++) {
        for (let r = 0; r < bricks[c].length; r++) {
            const brick = bricks[c][r];
            
            if (brick.status === 1) {
                balls.forEach(b => {
                    if (!b.active) return;
                    
                    // 簡單的矩形與圓形碰撞檢測
                    if (
                        b.x + b.radius > brick.x &&
                        b.x - b.radius < brick.x + brickWidth &&
                        b.y + b.radius > brick.y &&
                        b.y - b.radius < brick.y + brickHeight
                    ) {
                        // 更精確的碰撞檢測
                        let testX = b.x;
                        let testY = b.y;
                        
                        // 找出圓上最近的點
                        if (b.x < brick.x) testX = brick.x; // 左邊
                        else if (b.x > brick.x + brickWidth) testX = brick.x + brickWidth; // 右邊
                        
                        if (b.y < brick.y) testY = brick.y; // 頂部
                        else if (b.y > brick.y + brickHeight) testY = brick.y + brickHeight; // 底部
                        
                        // 計算距離
                        const distX = b.x - testX;
                        const distY = b.y - testY;
                        const distance = Math.sqrt(distX * distX + distY * distY);
                        
                        if (distance <= b.radius) {
                            // 碰撞發生
                            handleBrickCollision(b, brick, c, r, distX, distY, distance);
                        }
                    }
                });
            }
        }
    }
}

// 處理磚塊碰撞
function handleBrickCollision(ball, brick, col, row, distX, distY, distance) {
    // 不可破壞的磚塊只反彈球
    if (brick.type === BRICK_TYPES.UNBREAKABLE) {
        // 計算反彈角度
        const nx = distX / distance;
        const ny = distY / distance;
        
        // 計算反射向量
        const dot = ball.dx * nx + ball.dy * ny;
        ball.dx = ball.dx - 2 * dot * nx;
        ball.dy = ball.dy - 2 * dot * ny;
        
        // 播放聲音效果
        playSound('bounce');
        return;
    }
    
    // 減少磚塊耐久度
    brick.hits--;
    
    // 增加連擊
    combo++;
    document.getElementById('combo').textContent = combo;
    maxCombo = Math.max(maxCombo, combo);
    
    // 重置連擊計時器
    clearTimeout(comboTimeout);
    comboTimeout = setTimeout(() => {
        combo = 0;
        document.getElementById('combo').textContent = combo;
    }, 3000);
    
    // 顯示連擊效果
    if (combo >= 3) {
        showComboEffect(ball.x, ball.y, combo);
    }
    
    // 檢查磚塊是否被摧毀
    if (brick.hits <= 0) {
        brick.status = 0;
        totalBricksDestroyed++;
        
        // 根據磚塊類型給予分數
        let points = 10 * level; // 基礎分數
        
        switch(brick.type) {
            case BRICK_TYPES.HARD:
                points = 30 * level;
                break;
            case BRICK_TYPES.SPEED_UP:
                points = 20 * level;
                // 球速增加
                ball.speed *= 1.1;
                break;
            case BRICK_TYPES.POWER_UP:
                points = 50 * level;
                // 掉落能力道具
                createPowerup(brick.x + brickWidth/2, brick.y + brickHeight/2);
                break;
            case BRICK_TYPES.BONUS:
                points = 100 * level;
                break;
        }
        
        // 連擊獎勵
        if (combo >= 3) {
            points *= 1 + (combo * 0.1);
        }
        
        // 火球獎勵
        if (ball.isFireball) {
            points *= 1.5;
            
            // 火球爆炸效果
            createExplosion(brick.x + brickWidth/2, brick.y + brickHeight/2);
            
            // 摧毀周圍磚塊
            destroyNearbyBricks(col, row);
        }
        
        // 添加分數
        addScore(Math.floor(points));
        
        // 創建粒子效果
        createParticles(brick.x + brickWidth/2, brick.y + brickHeight/2, brick.type);
        
        // 播放聲音效果
        playSound('break');
    } else {
        // 播放聲音效果
        playSound('bounce');
    }
    
    // 計算反彈角度
    const nx = distX / distance;
    const ny = distY / distance;
    
    // 計算反射向量
    const dot = ball.dx * nx + ball.dy * ny;
    ball.dx = ball.dx - 2 * dot * nx;
    ball.dy = ball.dy - 2 * dot * ny;
    
    // 稍微增加球速
    ball.speed *= 1.005;
}

// 摧毀附近的磚塊（火球效果）
function destroyNearbyBricks(col, row) {
    const radius = 2; // 影響範圍
    
    for (let c = Math.max(0, col - radius); c <= Math.min(bricks.length - 1, col + radius); c++) {
        for (let r = Math.max(0, row - radius); r <= Math.min(bricks[c].length - 1, row + radius); r++) {
            const brick = bricks[c][r];
            
            if (brick.status === 1 && brick.type !== BRICK_TYPES.UNBREAKABLE) {
                // 計算距離
                const dx = c - col;
                const dy = r - row;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= radius) {
                    brick.hits = 0;
                    brick.status = 0;
                    totalBricksDestroyed++;
                    
                    // 創建粒子效果
                    createParticles(brick.x + brickWidth/2, brick.y + brickHeight/2, brick.type);
                }
            }
        }
    }
}

// 創建能力道具
function createPowerup(x, y) {
    const powerupTypes = Object.values(POWERUP_TYPES);
    const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
    
    powerups.push({
        x: x - 15,
        y: y,
        width: 30,
        height: 30,
        speed: 2,
        type: randomType
    });
}

// 激活能力
function activatePowerup(type) {
    switch(type) {
        case POWERUP_TYPES.EXTRA_BALL:
            // 創建一個新球
            const newBall = {
                x: paddle.x + paddle.width / 2,
                y: canvas.height - paddle.height - ball.radius,
                dx: 0,
                dy: 0,
                radius: ball.radius,
                speed: ball.speed,
                active: false,
                isFireball: false
            };
            balls.push(newBall);
            break;
            
        case POWERUP_TYPES.LARGE_PADDLE:
            paddle.isLarge = true;
            paddle.largeEndTime = Date.now() + 30000; // 30秒
            break;
            
        case POWERUP_TYPES.FIRE_BALL:
            // 所有球變為火球
            balls.forEach(b => {
                b.isFireball = true;
                b.fireballEndTime = Date.now() + 15000; // 15秒
            });
            break;
            
        case POWERUP_TYPES.STICKY_PADDLE:
            paddle.isSticky = true;
            break;
    }
    
    // 添加到激活能力列表
    activePowerups.push({
        type: type,
        endTime: Date.now() + (type === POWERUP_TYPES.STICKY_PADDLE ? 45000 : 30000) // 45秒或30秒
    });
    
    // 顯示能力獲得效果
    showPowerupEffect(type);
}

// 取消能力
function deactivatePowerup(type) {
    switch(type) {
        case POWERUP_TYPES.LARGE_PADDLE:
            paddle.isLarge = false;
            break;
            
        case POWERUP_TYPES.FIRE_BALL:
            balls.forEach(b => {
                b.isFireball = false;
            });
            break;
            
        case POWERUP_TYPES.STICKY_PADDLE:
            paddle.isSticky = false;
            break;
    }
}

// 創建粒子效果
function createParticles(x, y, brickType) {
    const particleCount = brickType === BRICK_TYPES.BONUS ? 20 : 10;
    let color;
    
    switch(brickType) {
        case BRICK_TYPES.HARD:
            color = '#9E9E9E';
            break;
        case BRICK_TYPES.POWER_UP:
            color = '#9C27B0';
            break;
        case BRICK_TYPES.SPEED_UP:
            color = '#FFC107';
            break;
        case BRICK_TYPES.BONUS:
            color = '#FFEB3B';
            break;
        default:
            color = BRICK_COLORS[Math.floor(Math.random() * BRICK_COLORS.length)];
    }
    
    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: x,
            y: y,
            radius: Math.random() * 4 + 2,
            color: color,
            alpha: 1,
            dx: (Math.random() - 0.5) * 4,
            dy: (Math.random() - 0.5) * 4
        });
    }
}

// 創建爆炸效果
function createExplosion(x, y) {
    for (let i = 0; i < 30; i++) {
        particles.push({
            x: x,
            y: y,
            radius: Math.random() * 6 + 3,
            color: `hsl(${Math.random() * 30 + 10}, 100%, 50%)`, // 橙紅色調
            alpha: 1,
            dx: (Math.random() - 0.5) * 8,
            dy: (Math.random() - 0.5) * 8
        });
    }
}

// 顯示連擊效果
function showComboEffect(x, y, combo) {
    const comboEl = document.createElement('div');
    comboEl.className = 'combo';
    comboEl.textContent = `${combo} Combo!`;
    comboEl.style.left = `${x}px`;
    comboEl.style.top = `${y}px`;
    document.body.appendChild(comboEl);
    
    // 自動移除
    setTimeout(() => {
        comboEl.remove();
    }, 1000);
}

// 顯示能力獲得效果
function showPowerupEffect(type) {
    let text = '';
    let color = '';
    
    switch(type) {
        case POWERUP_TYPES.EXTRA_BALL:
            text = '雙倍球!';
            color = '#FF5252';
            break;
        case POWERUP_TYPES.LARGE_PADDLE:
            text = '大擋板!';
            color = '#4CAF50';
            break;
        case POWERUP_TYPES.FIRE_BALL:
            text = '爆炸球!';
            color = '#FF9800';
            break;
        case POWERUP_TYPES.STICKY_PADDLE:
            text = '磁力擋板!';
            color = '#2196F3';
            break;
    }
    
    const effectEl = document.createElement('div');
    effectEl.className = 'combo';
    effectEl.textContent = text;
    effectEl.style.color = color;
    effectEl.style.left = `${canvas.width / 2}px`;
    effectEl.style.top = `${canvas.height / 2}px`;
    effectEl.style.fontSize = '32px';
    document.body.appendChild(effectEl);
    
    // 自動移除
    setTimeout(() => {
        effectEl.remove();
    }, 1500);
}

// 添加分數
function addScore(points) {
    score += Math.floor(points);
    updateScoreDisplay();
    
    // 更新最高分
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('breakoutHighScore', highScore);
    }
}

// 更新分數顯示
function updateScoreDisplay() {
    document.getElementById('score').textContent = score;
}

// 檢查遊戲狀態
function checkGameState() {
    // 檢查是否所有磚塊都被摧毀
    let allDestroyed = true;
    for (let c = 0; c < bricks.length; c++) {
        for (let r = 0; r < bricks[c].length; r++) {
            if (bricks[c][r].status === 1 && bricks[c][r].type !== BRICK_TYPES.UNBREAKABLE) {
                allDestroyed = false;
                break;
            }
        }
        if (!allDestroyed) break;
    }
    
    if (allDestroyed) {
        // 過關
        document.getElementById('currentLevel').textContent = level;
        document.getElementById('levelUpModal').style.display = 'flex';
    }
}

// 顯示遊戲結束
function showGameOver() {
    document.getElementById('gameResultTitle').textContent = '遊戲結束!';
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalHighScore').textContent = highScore;
    document.getElementById('finalLevel').textContent = level;
    document.getElementById('finalBricks').textContent = totalBricksDestroyed;
    document.getElementById('gameOverModal').style.display = 'flex';
}

// 播放聲音效果
function playSound(type) {
    // 這裡可以添加聲音播放代碼
    // 實際實現需要預加載音頻文件
}

// 初始化遊戲
window.onload = init;

